# **Personal Project**

## 고속 이미지 검색을 지원하는 이미지 기반 추천 시스템

배포 주소 : https://port-0-recommendsystem-m06bzsd06bb1d433.sel4.cloudtype.app/shop/main

### 프로젝트 소개


> **VGG16 모델과 Bitwise AND 연산을 활용한 유사 이미지 추천 시스템**
> 
- 현재 보고 있는 상품 이미지와 시각적으로 유사한 이미지의 상품을 보여주는 시스템
- VGG16 모델을 통해 추출한 고차원 특징점(Image Feature)를 간소화
- ANN 탐색 방법을 통해 일정 수준의 정확도를 유지하면서 성능 최적화를 진행

### 주요 기능

![흐름도 2](https://github.com/user-attachments/assets/b7674751-907a-4e78-96a9-eba6dd48a500)


- **사전 학습된 VGG16 모델을 활용한 Feature 추출 및 간소화**
    - 25,088차원의 이미지 Feature 벡터를 이진화하여 메모리 사용량 절감
    - 필터 반응 강도(intensity)를 기준으로 상위 25개 필터의 번호를 저장하고 검색에 활용
- **Bitwise AND 연산을 활용한 유사 이미지 추천**
    - 사용자가 현재 보고 있는 상품 이미지와 시각적으로 유사한 이미지의 상품을 추천
    - 특정 필터 번호를 포함하는 상품을 AND 비트 연산으로 반복적으로 필터링하여 후보군을 점진적으로 축소
    - 남은 상품 개수가 일정 이하가 되면 질의 이미지와 유사한 Top-N개의 상품을 선별

### 성능

- Top-5 accuracy : 92.7%
- Top-10 accuracy : 86.7%
- 검색 속도 : 평균 49.93ms
- 메모리 차지 용량 : 64MB
(1,000,000개의 상품 데이터 저장 기준)

### 사용한 기술 스택

| 구분 | 버전 |
| --- | --- |
| Framework | SpringBoot
FastAPI |
| DBMS | MySQL |
| 데이터 접근 기술 | Mybatis
JPA |
| Infra | AWS S3
Redis |

<br>

## 구현 및 기술 도입 과정

### 용어 정리

이미지 검색 (Image-to-Image retrieval)

- 주어진 질의(query) 이미지를 기반으로 대규모 이미지 데이터베이스에서 유사한 이미지를 찾아내는 것을 목표로 한다.
- 내용 기반 이미지 검색(Content-Based Image Retrieval, CBIR)은 시각적 특징에 중점을 둔 검색 방식으로, 색상, 질감, 모양 등 시각적 특징을 분석하여 검색 결과를 반환한다.

이미지 매칭 (Image Matching)

- 두 개 이상의 이미지를 비교하여 이미지 사이의 유사한 특징을 찾는 작업이다.
- 특징 추출을 통한 이미지 매칭은 가장 널리 쓰이는 기법으로 이미지에서 중요한 지점(특징점)을 찾아낸 다음, 유사도를 측정해 매칭 결과를 도출한다.

VGGNet이란
![qS1ZNWI](https://github.com/user-attachments/assets/67883b52-c55c-4ff8-8104-6649ae36e81b)

- VGGNet은 옥스포드 대학의 연구팀 VGG에 의해 개발된 모델로써, 2014년 ImageNet 이미지 인식 대회에서 준우승을 한 모델이다.
- VGG16은 16개의 가중치 레이어로 구성된 VGGNet 모델을 의미한다.
- 가장 마지막 합성곱(convolution) 레이어의 경우 512개의 1 x 7 x 7size의 필터(feature map)으로 구성되어 있으며, 25,088차원의 이미지의 feature를 추출한다.

<br>

### 요구사항

각각 25,088차원을 가진 수십만개의 이미지의 특징점을 검색에 사용하면 저장공간과 검색 속도 측면에서 문제가 발생할 수 있다. 이미지 검색 방식을 도입하려면 아래의 요구사항을 만족해야 한다.

1. 신규 등록한 상품의 이미지를 비교하기 때문에 매우 빠른 처리속도(near-realtime)를 보여야 한다.
2. 추천 상품 이미지는 질의 이미지와 시각적으로 유사한 특징을 보여야 한다.
3. 서버 및 인프라 자원을 너무 과도하게 사용해서는 안된다.

<br>

### 탐색 방안

방법 1 - LSH-MinHash 알고리즘

- LSH-MinHash 알고리즘은 유사 문서 검색, 이미지 검색 등 차원이 큰 데이터를 다룰 때 자주 사용된다.
이미지 특징점을 고정된 크기의 집합으로 변환하면 검색 정확도를 유지하면서 저장공간을 줄일 수 있다.
- Min-Hash 알고리즘 : 고차원 데이터를 고정된 크기의 집합으로 변환
- LSH 알고리즘 : 유사한 데이터를 같은 버킷(Bucket)에 할당하여 검색 속도를 향상

방법 2 - 필터의 반응 강도와 Bitwise AND 연산 활용

- VGG16의 경우, input 이미지를 512개의 필터(feature map)에 통과시켜 특징점을 추출한다.
유사한 이미지는 필터의 반응 강도(feature map의 평균값) 또한 유사하다.
- 따라서 필터의 반응 강도를 활용해 상품을 필터링한다면, 검색 속도를 향상시키고 연산량을 줄일 수 있다.

<br>

### 이미지 특징점 간소화

VGG16 모델을 이용하여 추출한 1개의 이미지 특징점은 실수 타입의 25,088차원의 데이터로 100,352(byte)의 저장공간이 필요하다.

추출이 끝난 특징점을 0을 제외한 값들의 평균을 기준으로 이진화(Binarization)를 수행하였다. 이를 통해 특징점의 크기는 3136Byte로 감소하였다.

- 완전 탐색 방식의 테스트 결과 및 기존 연구를 통해 이진화가 검색 정확도에 큰 영향을 미치지 않음을 검증하였다.
- VGG16 모델은 ReLU 함수를 사용하여 음수인 특징점의 값을 0으로 변환한다. 만약 특징점의 평균을 계산할 때 0을 포함한다면, 평균이 너무 낮아져 이진화를 제대로 수행할 수 없다.

### Search data 생성

방법 1의 경우

- 이진화된 특징점에 MinHash 알고리즘을 적용하여 고정된 길이의 정수 집합(signature)로 변환한다. Signature의 길이가 500일 때 검색 속도와 정확도의 균형을 맞출 수 있었다.
- 변환된 signature를 일정한 길이로 분할한 후, 별도의 해시 함수를 적용한다. 동일한 해시값을 갖는 경우, 동일한 버킷에 상품 번호와 signature를 함께 저장한다(Bucket Hashing).
- 1개의 search data를 저장하는데 필요한 저장공간 : 2000byte

방법 2의 경우

- VGG16  모델의 마지막 합성곱 층에 Global Average Pooling을 적용하여 각 필터의 반응 강도를 측정한 다음, 반응이 가장 큰 25개의 필터 번호를 비트 벡터(Bit Vector)로 저장한다.
(Global Average Pooling : 합성곱 신경망(CNN)에서 feature map의 공간 정보를 평균 내어 하나의 값으로 변환하는 기법)
- 비트 벡터란 중복되지 않는 정수 집합을 비트로 나타내는 방식으로, 비트 연산을 통해 특정 필터의 유무를 빠르고 간단하게 체크할 수 있다.
- 정확한 유사도 측정을 위해 별도의 저장공간에서 이미지의 특징점을 조회할 필요가 있다.
- 1개의 search data를 저장하는데 필요한 저장공간 : 64byte

<br>

### 검색 방법

방법 1의 경우 

- 현재 보고 있는 상품 이미지의 특징점에 MinHash와 Bucket Hashing을 수행한 다음,  같은 버킷에 속한 모든 이미지끼리 자카드 유사도 연산을 통해 유사도를 측정한다.

방법 2의 경우

- 현재 보고 있는 상품 이미지의 필터 반응 강도가 큰 순서대로, 특정 필터 번호를 포함하는 상품을 AND 비트 연산으로 반복적으로 필터링하여 후보군을 점진적으로 축소한다.
- 남은 상품번호의 개수가 300개 이하이거나 25개의 필터 번호를 모두 순회한 경우, 질의 이미지와 남은 상품 이미지의 유사도를 계산한다.

<br>

### 성능 측정 및 장단점 비교

AI 허브에서 제공하는 ‘상품 이미지’ 데이터 셋을 이용해서 이미지 검색 성능 평가를 수행하였다. ‘상품 이미지’ 데이터 셋은 음료, 과자, 디저트, 면류 등 편의점 상품 데이터 10,000건으로 구성되어 있다.

유사 이미지 탐색 정확도는 검색 결과 10개 중 질의 이미지와 시각적으로 유사한 이미지의 비율로 측정하였다.

검색 속도는 100개의 유사 이미지 검색을 수행하는 시간을 측정한 다음, 평균을 내었다.

![화면 캡처 2025-03-06 203409](https://github.com/user-attachments/assets/0c32e224-5d92-487b-bb55-574c949d6e1e)


LSH-MinHash 방식을 활용한 유사 이미지 검색의 경우 Top-5 accuracy는 93.3%, Top-10 accuracy는 89.6%, 평균 실행 시간은 33.60ms로 우수한 성능을 보였다. 

- 장점
    - VGGNet뿐만 아니라 GoogLeNet, ResNet 등 다른 특징점 추출 모델로 변경하더라도 정상적으로 동작하는 높은 유연성을 가진다.
- 단점
    - LSH-MinHash 알고리즘의 특성상, 동일한 입력 벡터라도 서로 다른 LSH 객체는 다른 해시값 및 시그니처(signature)를 생성한다. 이는 LSH 객체가 인스턴스화될 때 해싱 함수의 매개변수가 무작위로 초기화되기 때문이다.
    따라서 질의 데이터와 유사한 값을 탐색하려면, 매번 새로운 LSH 버킷을 생성하여 검색을 수행하거나 초기 시드(seed)를 제공하여 해싱 함수의 랜덤성을 제어해야 한다.
    - signature의 분할 길이와 버킷의 수는 정확도와 실행 속도에 영향을 미치므로, 상품 개수에 따라 파라미터를 조정해주어야 한다.
    - 버킷 수가 많아질수록 동일한 상품 번호와 signature가 중복 저장되는 문제가 발생한다.이로 인해 상품 개수가 증가할수록 search data 저장 공간이 지수적으로 증가한다.

Bitwise AND 연산을 활용한 유사 이미지 검색의 경우  Top-5 accuracy는 92.0%, Top-10 accuracy는 86.7%, 평균 실행 시간은 169.63ms로  다소 느린 검색 성능을 보였다.

- 장점
    - 고객의 행동 데이터나 상품 후기를 반영하여 더욱 정교한 추천 로직을 구축하거나, 품절 상품을 제외하는 등 다양한 실무적 응용이 가능하다
    - LSH 방식에 비해 검색 데이터 저장 공간이 최소 30배 이상 적게 들며, 상품 개수가 증가하더라도 저장 공간이 선형적으로 증가하므로 인프라 확장 시점을 예측하기 쉽다
- 단점
    - LSH-MinHash 방식과 비교하면  Top-10 accuracy가 낮고 실행 속도가 느리다.
    - 이러한 성능 저하의 원인은 필터의 반응 강도를 기반으로 이미지를 간접적으로 필터링하고, 고차원 특징점을 직접 사용하여 유사도를 측정하기 때문에 연산량이 증가하기 때문으로 추측된다.
    - 이미지를 필터링하려면 전체 검색 데이터를 최소 한 번 이상 순회해야 한다.
    

두 방식의 장단점을 비교한 결과, 실행 속도는 조금 떨어지지만 다양한 실무적 응용이 가능하고 서버 및 인프라 자원을 적게 사용하는 **필터의 반응 강도와 Bitwise AND 연산** 방식을 도입하였다.

<br>

## 트러블 슈팅

현재 Bitwise AND 연산을 활용한 검색 방식의 실행 시간은 169.63ms로, 상당히 느린 편이다.

검색 과정을 세분화하여 분석한 결과, DB에서 이미지 특징점을 조회하는 작업이 가장 오래 걸리며 실행 시간 편차도 크다.

즉, DB 연동 과정이 주요 병목 요인일 가능성이 높다.

### **SQL 쿼리 튜닝**

문제점

- 기존 쿼리는 WHERE IN(…)절을 사용하여 UUID 리스트를 기반으로 특징점을 조회했다.
- 하지만 UUID 개수가 많아질수록 DB 옵티마이저가 모든 값을 개별적으로 평가해야 하므로 비효율적인 실행 계획이 생성된다.

개선 방안

- 서브 쿼리를 활용해 UUID 리스트를 임시 테이블로 변환한 다음, INNER JOIN을 사용하여 이미지 특징점을 조회하도록 수정
- JOIN시 인덱스를 활용하여 쿼리 실행 속도를 단축
- 튜닝 결과, 평균 실행 시간이 79.7ms로 감소

```sql
<-- 수정된 쿼리 -->
<select id="findPreFilterTarget" parameterType="list" resultType="PreFilterDto">
    SELECT 
        i.image_uuid, 
        i.img_feature_value
    FROM 
        image_info AS i
    INNER JOIN (
        <foreach collection="list" item="item" separator=" UNION ALL ">
            SELECT #{item} AS image_uuid
        </foreach>
    ) AS temp_table
    ON i.image_uuid = temp_table.image_uuid
</select>
```

### 쿼리 실행횟수 줄이기

문제점

- 현재 검색 방식에서는 두번의 쿼리가 실행된다.
    - 첫 번째 쿼리 : 특징점 조회
    - 두 번째 쿼리 : 상품 상세 정보 조회
- DB는 외부 클라우드 환경에 위치하고 있어 네트워크 상태에 따라 실행 시간이 크게 변동될 수 있다.
- 개별 쿼리 실행이 많아질수록 DB 부하가 증가해 성능 저하의 원인이 될 가능성이 크다.

개선 방안

- 현재 추천 로직의 전체 흐름은 다음과 같다.
    1. 질의 이미지에서 특징점 추출
    2. 검색 로직 실행 (상품의 UUID 및 유사도 반환)
    3. 상품 상세 정보를 DB에서 조회한 후, 유사도 순으로 정렬하여 화면에 전달
- 2번 작업(상품 UUID 및 유사도 반환)과 3번 작업(상품 상세 정보 조회)을 합쳐, 한 번의 쿼리로 특징점과 상품 상세 정보를 동시에 조회하도록 로직을 수정
- 개선 후 평균 실행 시간이 49.93ms로 단축, 기존 대비 3.4배 속도 향상

이러한 개선을 통해 네트워크 환경에 따른 실행 시간 변동성을 줄이고, 전반적인 검색 성능을 크게 개선하였다.

<br>

## 화면 구성

![화면 캡처 2025-01-22 023945](https://github.com/user-attachments/assets/02367d7d-28f6-495b-9e2f-2854ee016c50)
